section .data
    num     db 0             ; Определение переменной num как двойного слова (4 байта)
    buffer  resb 10          ; Определение буфера buffer как массива из 10 байт

section .text
    global _start

loop: 

	; Increment Varibale num by 1
	add byte [num], 1

	; Condition To Exit ( If Overflow Flag is established )
	jo exit
    ; Передача значения числа и указателя на буфер в функцию int_to_string
    mov    eax, [num]       ; Помещаем значение числа в eax
    lea    esi, [buffer]    ; Указываем esi на начало буфера
    call   int_to_string    ; Вызываем функцию для преобразования числа в строку

    ; eax теперь содержит указатель на начало строки в буфере, который мы можем использовать для вывода
    ; Реализация вывода строки на стандартный вывод (stdout) с использованием системного вызова sys_write
    mov    edx, ecx         ; Длина строки (хранится в ecx) для передачи в sys_write
    mov    ecx, eax         ; Указатель на начало строки для передачи в sys_write
    mov    ebx, 1           ; Дескриптор вывода (стандартный вывод)
    mov    eax, 4           ; Вызываем sys_write
    int    0x80             ; Прерывание для выполнения системного вызова
	
    ; eax теперь содержит указатель на начало строки в буфере, который мы можем использовать для вывода
    ; Реализация вывода строки на стандартный вывод (stdout) с использованием системного вызова sys_write
    mov    edx, ecx         ; Длина строки (хранится в ecx) для передачи в sys_write
    mov    ecx, eax         ; Указатель на начало строки для передачи в sys_write
    mov    ebx, 1           ; Дескриптор вывода (стандартный вывод)
    mov    eax, 4           ; Вызываем sys_write
    int    0x80             ; Прерывание для выполнения системного вызова

	jmp loop

_start:

	jmp loop   

; Функция int_to_string
; Input:
; eax = целочисленное значение для преобразования
; esi = указатель на буфер для сохранения строки (должен иметь место для не менее 10 байт)
; Output:
; eax = указатель на первый символ сгенерированной строки
; ecx = длина сгенерированной строки
int_to_string:
    add    esi, 9           ; Указываем esi на последний символ буфера
    mov    byte [esi], 0    ; Устанавливаем нулевой терминатор строки

    mov    ebx, 10          ; Делитель для деления числа
.next_digit:
    xor    edx, edx         ; Очищаем edx перед делением edx:eax на ebx
    div    ebx              ; Делим eax на 10
    add    dl, '0'          ; Преобразуем остаток в символ ASCII цифры
    dec    esi              ; Сохраняем символы в обратном порядке
    mov    [esi], dl        ; Записываем символ в буфер
    test   eax, eax
    jnz    .next_digit      ; Повторяем, пока eax не станет равным 0

    ; Возвращаем указатель на первый символ строки
    mov    eax, esi         ; Помещаем в eax адрес начала строки
    sub    eax, 1           ; Корректируем eax на 1, чтобы указывать на первый символ
    mov    ecx, 10          ; Длина строки (максимально 10 символов)

    ret

exit: 

    ; Выход из программы
    mov    eax, 1           ; Код завершения программы (со значением 0)
    xor    ebx, ebx         ; Очистка регистра ebx
    int    0x80             ; Вызов системного вызова для завершения программы

